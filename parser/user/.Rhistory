rft = randomForest(X,y,ntree = 500,mtry = sqrt(n),nodesize = 5)
n = 5
rft = randomForest(X,y,ntree = 500,mtry = sqrt(n),nodesize = 5)
str(X)
str(y)
# a)
set.seed(123)
# generate X
X = matrix(0, 200, 4)
for (i in 1:4){
X[,i] = rnorm(200,0,1)
}
# b) and c)
err = rnorm(200,0,1)
y = 3 + 2*X[,1] - X[,2] + 1.5*X[,3] + 4*X[,4] + err
# d)
n = 5
rft = randomForest(X,y,ntree = 500,mtry = sqrt(n),nodesize = 5)
summary(rft)
rft
n = 5
rft = randomForest(X,y,ntree = 500,mtry = sqrt(n),nodesize = 5)
# e)
set.seed(123)
yi = matrix(0, 200,10)
yis = matrix(0, 200,10)
for (i in 1:10){
err = rnorm(200,0,1)
y = 3 + 2*X[,1] - X[,2] + 1.5*X[,3] + 4*X[,4] + err
rft = randomForest(X,y,ntree = 500,mtry = sqrt(n),nodesize = 5)
y_hat = predict(rft, X)
yi[,i] = y
yis[,i] = y_hat
}
# f)
y_and_y_hat = cbind(yi,yis)
y_cov = apply(y_and_y_hat,MARGIN = 1,FUN = function(x){
return(cov(x[1:10],x[11:20]))
})
df = sum(y_cov)
df
?expand.grid
ntree = c(100,200,300,400,500,500)
mtry = c(1,2,3,4)
nodesize = c(1,5,10,20)
all_situation = expand.grid(ntree,mtry,nodesize)
all_situation
all_situation[1]
all_situation[2]
all_situation[3]
all_situation
names(all_situation)
names(all_situation) = c("ntree","mtry","nodesize")
ntree = c(100,200,300,400,500)
mtry = c(1,2,3,4)
nodesize = c(1,5,10,20)
all_situation = expand.grid(ntree,mtry,nodesize)
names(all_situation) = c("ntree","mtry","nodesize")
linear_grid$best.performance
poly_grid$best.performance
rbf_grid$best.performance
sig_grid$best.performance
seq(0,1,0.1)
seq(0.1,1,0.1)
# Load data
data = SAheart
data$famhist = as.integer(data$famhist)
data$famhist = ifelse(data$famhist==1,0,1)
data$chd = as.factor(data$chd)
# kernels and cost with grid search
# the basic model use the linear kernel with cost = 1
benchmodel = svm(chd~., data = train, kernel = "linear",cost = 1, cross = 10)
acc_bench = mean(benchmodel$accuracies)
# linear kernel
set.seed(123)
linear_grid = tune.svm(chd~., data = data, kernel="linear", cost=2^(-7:8), cross=10)
# summary(linear_grid)
# plot(linear_grid)
linear_grid$best.performance
# Polynomial kernel
# What is the gamma and coef
set.seed(123)
poly_grid = tune.svm(chd~., data = data, kernel="polynomial", cost=2^(-7:8), degree = 2:5,cross=10)
# summary(poly_grid)
# plot(poly_grid)
poly_grid$best.performance
# RBF
set.seed(123)
rbf_grid = tune.svm(chd~., data = data, kernel="radial", cost=2^(-7:8), gamma = 2^(-12:3), cross=10)
# summary(rbf_grid)
# plot(rbf_grid)
rbf_grid$best.performance
# Neural
# What is the gamma and coef
set.seed(123)
sig_grid = tune.svm(chd~., data = data, kernel="sigmoid", cost=2^(-7:8), gamma = 2^(-5:3), coef0 = 2^(-5:5), cross=10)
# summary(sig_grid)
# plot(sig_grid)
sig_grid$best.performance
# Question 3
# HW3 R Script
# Question 1
library(ElemStatLearn)
library(e1071)
library(ggplot2)
library(randomForest)
# Load data
data = SAheart
data$famhist = as.integer(data$famhist)
data$famhist = ifelse(data$famhist==1,0,1)
data$chd = as.factor(data$chd)
# kernels and cost with grid search
# the basic model use the linear kernel with cost = 1
benchmodel = svm(chd~., data = train, kernel = "linear",cost = 1, cross = 10)
acc_bench = mean(benchmodel$accuracies)
# linear kernel
set.seed(123)
linear_grid = tune.svm(chd~., data = data, kernel="linear", cost=2^(-7:8), cross=10)
# summary(linear_grid)
# plot(linear_grid)
linear_grid$best.performance
# Polynomial kernel
# What is the gamma and coef
set.seed(123)
poly_grid = tune.svm(chd~., data = data, kernel="polynomial", cost=2^(-7:8), degree = 2:5,cross=10)
# summary(poly_grid)
# plot(poly_grid)
poly_grid$best.performance
# RBF
set.seed(123)
rbf_grid = tune.svm(chd~., data = data, kernel="radial", cost=2^(-7:8), gamma = 2^(-12:3), cross=10)
# summary(rbf_grid)
# plot(rbf_grid)
rbf_grid$best.performance
# Neural
# What is the gamma and coef
set.seed(123)
sig_grid = tune.svm(chd~., data = data, kernel="sigmoid", cost=2^(-7:8), gamma = 2^(-5:3), coef0 = 2^(-5:5), cross=10)
# summary(sig_grid)
# plot(sig_grid)
sig_grid$best.performance
poly_grid
summary(poly_grid)
summary(rbf_grid)
rbf_grid$best.performance
rbf_grid
sig_grid
linear_grid$best.performance
linear_grid
a = linear_grid
b = poly_grid
c = rbf_grid
d = sig_grid
eq(0.2,0.4,0.0125)
seq(0.2,0.4,0.0125)
set.seed(123)
linear_grid = tune.svm(chd~., data = data, kernel="linear", cost=seq(0.2,0.4,0.0125), cross=10)
# summary(linear_grid)
# plot(linear_grid)
linear_grid
# a = linear_grid
summary(linear_grid)
cost=seq(0.2,0.4,0.0125)
cost
v
seq(0.02,0.04,0.0125)
seq(0.02,0.04,0.00125)
# linear kernel
set.seed(123)
linear_grid = tune.svm(chd~., data = data, kernel="linear", cost=seq(0.02,0.04,0.00125), cross=10)
# summary(linear_grid)
# plot(linear_grid)
linear_grid
# a = linear_grid
set.seed(123)
poly_grid = tune.svm(chd~., data = data, kernel="polynomial", cost=seq(0.3,1,0.1), degree = 3,cross=10)
# summary(poly_grid)
# plot(poly_grid)
poly_grid
# What is the gamma and coef
set.seed(123)
poly_grid = tune.svm(chd~., data = data, kernel="polynomial", cost=seq(0.3,0.7,0.01), degree = 3,cross=10)
# summary(poly_grid)
# plot(poly_grid)
poly_grid
# b = poly_
# RBF
set.seed(123)
rbf_grid = tune.svm(chd~., data = data, kernel="radial", cost=4:16, gamma = seq(0.0015,0.0025,0.0001), cross=10)
summary(rbf_grid)
# plot(rbf_grid)
rbf_grid
# c = rbf_grid
# RBF
set.seed(123)
rbf_grid = tune.svm(chd~., data = data, kernel="radial", cost=4:16, gamma = seq(0.0018,0.0030,0.0001), cross=10)
summary(rbf_grid)
# plot(rbf_grid)
rbf_grid
# c = rbf_grid
sig_grid
set.seed(123)
sig_grid = tune.svm(chd~., data = data, kernel="sigmoid", cost=seq(0.2,0.3,0.01), gamma = seq(0.5,0.7,0.0025), coef0 = seq(0.5,0.7,0.0025), cross=10)
set.seed(123)
sig_grid = tune.svm(chd~., data = data, kernel="sigmoid", cost=seq(0.2,0.3,0.01), gamma = seq(0.05,0.07,0.0025), coef0 = seq(0.05,0.07,0.0025), cross=10)
# summary(sig_grid)
# plot(sig_grid)
sig_grid
# d = sig_gr
plot(sig_grid)
summary(sig_grid)
plot(rbf_grid)
plot(poly_grid)
summary(poly_grid)
plot(poly_grid)
poly_grid
plot(linear_grid)
set.seed(123)
poly_grid = tune.svm(chd~., data = data, kernel="polynomial", cost=seq(0.3,0.7,0.01), degree = 3,cross=10)
summary(poly_grid)
poly_grid
plot(linear_grid)
title("Linear kernel")
plot(linear_grid)
title("Linear kernel")
plot(linear_grid, main = "Linear kernel")
p
p = ggplot(all_situation, aes(x=ntree, y=df)) + geom_line() + facet_grid(. ~ mtry + nodesize)
p
set.seed(123)
# generate X
X = matrix(0, 200, 4)
for (i in 1:4){
X[,i] = rnorm(200,0,1)
}
# b) and c)
err = rnorm(200,0,1)
y = 3 + 2*X[,1] - X[,2] + 1.5*X[,3] + 4*X[,4] + err
# d)
n = 5
rft = randomForest(X,y,ntree = 100,mtry = 2,nodesize = 5)
y_hat = predict(rft, X)
# e)
set.seed(123)
yi = matrix(0, 200,10)
yis = matrix(0, 200,10)
for (i in 1:10){
err = rnorm(200,0,1)
y = 3 + 2*X[,1] - X[,2] + 1.5*X[,3] + 4*X[,4] + err
rft = randomForest(X,y,ntree = 100,mtry = 2,nodesize = 5)
y_hat = predict(rft, X)
yi[,i] = y
yis[,i] = y_hat
}
# f)
y_and_y_hat = cbind(yi,yis)
y_cov = apply(y_and_y_hat,MARGIN = 1,FUN = function(x){
return(cov(x[1:10],x[11:20]))
})
df = sum(y_cov)
# g)
ntree = c(100,200,300,400,500)
mtry = c(1,2,3,4)
nodesize = c(1,5,10,20,30,40,50)
all_situation = expand.grid(ntree,mtry,nodesize)
all_situation$df = 0
names(all_situation) = c("ntree","mtry","nodesize","df")
for (i in 1:nrow(all_situation)){
set.seed(123)
yi = matrix(0, 200,10)
yis = matrix(0, 200,10)
for (j in 1:10){
err = rnorm(200,0,1)
y = 3 + 2*X[,1] - X[,2] + 1.5*X[,3] + 4*X[,4] + err
rft = randomForest(X,y,ntree = all_situation[i,"ntree"],
mtry = all_situation[i,"mtry"],
nodesize = all_situation[i,"nodesize"])
y_hat = predict(rft, X)
yi[,j] = y
yis[,j] = y_hat
}
y_and_y_hat = cbind(yi,yis)
y_cov = apply(y_and_y_hat,MARGIN = 1,FUN = function(x){
return(cov(x[1:10],x[11:20]))
})
df = sum(y_cov)
all_situation[i,"df"] = df
}
p = ggplot(all_situation, aes(x=ntree, y=df)) + geom_line() + facet_grid(. ~ mtry + nodesize)
p
a = 1
a
print(a)
library(glmnet)
iris
str(iris)
fit = glmnet(Species~.,data = iris)
?glmnet
X = iris[,1:4]
y = iris[,5]
fit = glmnet(X,y,family = "binomial",alpha = 1)
fit = glmnet(X,y,family = "multinomial",alpha = 1)
y
X
fit = glmnet(X,y,family = "multinomial",alpha = 1)
str(X)
str(y)
g2=sample(1:2,100,replace=TRUE)
fit2=glmnet(x,g2,family="binomial")
x=matrix(rnorm(100*20),100,20)
g2=sample(1:2,100,replace=TRUE)
fit2=glmnet(x,g2,family="binomial")
g2
predict(fit2,x)
pred = predict(fit2,x)
pred
str(pred)
str(X)
str(x)
pred = predict(fit2,x,type="response")
pred
pred = predict(fit2,x,type="response",s=0.01)
pred
?predict
pred = predict(fit2,x)
pred = predict(fit2,x,s = 0.01)
pred
shiny::runApp('repo/JobParser/parser/shiny-test')
faithful
runApp('repo/JobParser/parser/shiny-test')
runApp('repo/JobParser/parser/shiny-test')
runApp('repo/JobParser/parser/shiny-test')
runApp('repo/JobParser/parser/shiny-test')
runApp('repo/JobParser/parser/shiny-test')
runApp('repo/JobParser/parser/shiny-test')
runApp('repo/JobParser/parser/shiny-test')
?fluidPage
runApp('repo/shiny-examples-master/063-superzip-example')
runApp('repo/shiny-examples-master/064-telephones-by-region')
runApp('repo/JobParser/parser/shiny-test')
runif()
runif(10)
?rgamma
shiny::runApp('repo/JobParser/parser/shiny-test')
runApp('repo/JobParser/parser/shiny-test')
shiny::runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
integer(c(1.0,2.0))
integer(1)
integer(2.1)
integer(2,1)
?integer
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
?hr
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
?aggregate
shiny::runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
runApp('repo/JobParser/parser/user')
cls
runApp('repo/JobParser/parser/user')
skillData = jobData[,c("state"," CA")]
skillData = jobData[,c("state","CA")]
skillData = jobData[,c("state")]
skillData = jobData[,c("state","c..")]
skillData
agg = aggregate(skill$name,by=skill$state,FUN=sum)
agg = aggregate(skillData$name,by=skillData$state,FUN=sum)
name = "c.."
agg = aggregate(skillData$name,by=skillData$state,FUN=sum)
?aggregate
name = "Java"
skillData = jobData[,c("state",name)]
names(skillData)
names(jobData)
name = "java"
skillData = jobData[,c("state",name)]
skillData
agg = aggregate(java~state,data=skillData,sum)
agg
agg = aggregate(name~state,data=skillData,sum)
agg = aggregate(get(name)~state,data=skillData,sum)
agg
names(agg) = c("state","count")
data = agg
runApp('repo/JobParser/parser/user')
names(jobData)
names(jobData)[2] = "c++"
library(ggplot2)
library(scales)
jobData = read.csv("./data/jobFrame.csv",header = T)
names(jobData)[2] = "c++"
state = levels(jobData$state)
skill = names(jobData)[-1]
getwd()
setwd("~/repo/JobParser/parser/user")
jobData = read.csv("./data/jobFrame.csv",header = T)
names(jobData)[2] = "c++"
state = levels(jobData$state)
skill = names(jobData)[-1]
runApp()
name = "c++"
get(name)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
name = "java"
skill = jobData[,c("state",name)]
agg = aggregate(skill[,name]~skill[,"state"],sum)
skill[,name]
skill[,"state"]
agg = aggregate(skill[,name]~skill[,"state"],data=skill,sum)
agg
names(agg) = c("state","count")
data = agg
data
runApp()
data
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
capitaliz("aa")
install.packages("Hmisc")
install.packages("Hmisc")
library(Hmisc)
library(ggplot2)
library(scales)
library(Hmisc)
setwd("~/repo/JobParser/parser/user")
jobData = read.csv("./data/jobFrame.csv",header = T)
names(jobData)[2] = "c++"
state = levels(jobData$state)
skill = names(jobData)[-1]
shiny::runApp()
runApp()
runApp()
library(ggplot2)
library(scales)
